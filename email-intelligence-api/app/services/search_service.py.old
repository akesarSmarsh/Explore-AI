"""Search service for semantic and keyword search."""
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import or_

from app.models import Email, Entity
from app.core.embeddings import embedding_processor
from app.core.vector_store import vector_store
from app.core.bm25_search import bm25_search
from app.config import settings
from app.schemas.search import (
    SemanticSearchRequest, SearchResult, SearchFilters,
    KeywordSearchRequest, SimilarEmailRequest
)


class SearchService:
    """Service for search operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def semantic_search(self, request: SemanticSearchRequest) -> List[SearchResult]:
        """
        Perform semantic search on emails.
        Uses hybrid search (BM25 + semantic) if enabled.
        
        Args:
            request: Search request with query and filters
            
        Returns:
            List of search results
        """
        # Use hybrid search if enabled and BM25 index is available
        if settings.enable_hybrid_search and bm25_search.bm25:
            return self.hybrid_search(request)
        
        # Fall back to pure semantic search
        return self._pure_semantic_search(request)
    
    def _pure_semantic_search(self, request: SemanticSearchRequest) -> List[SearchResult]:
        """
        Perform pure semantic search without BM25.
        
        Args:
            request: Search request with query and filters
            
        Returns:
            List of search results
        """
        # Generate query embedding
        query_embedding = embedding_processor.encode(request.query)
        
        # Build metadata filter for ChromaDB
        where_filter = None
        if request.filters:
            where_filter = self._build_chroma_filter(request.filters)
        
        # Search in vector store
        search_results = vector_store.search(
            query_embedding=query_embedding,
            n_results=request.limit * 2,  # Get extra for post-filtering
            where=where_filter
        )
        
        # Get email details and apply additional filters
        results = []
        for i, email_id in enumerate(search_results["ids"]):
            email = self.db.query(Email).filter(Email.id == email_id).first()
            if not email:
                continue
            
            # Apply date filters if not handled by ChromaDB
            if request.filters:
                if request.filters.date_from and email.date:
                    # Compare dates, handling timezone-naive datetimes
                    email_date = email.date.replace(tzinfo=None) if email.date.tzinfo else email.date
                    filter_from = request.filters.date_from.replace(tzinfo=None) if request.filters.date_from.tzinfo else request.filters.date_from
                    if email_date < filter_from:
                        continue
                if request.filters.date_to and email.date:
                    # Compare dates, handling timezone-naive datetimes
                    # Add 1 day to date_to to include the entire end day
                    email_date = email.date.replace(tzinfo=None) if email.date.tzinfo else email.date
                    filter_to = request.filters.date_to.replace(tzinfo=None) if request.filters.date_to.tzinfo else request.filters.date_to
                    # If date_to has no time component (00:00:00), include the entire day
                    if filter_to.hour == 0 and filter_to.minute == 0 and filter_to.second == 0:
                        filter_to = filter_to + timedelta(days=1) - timedelta(seconds=1)
                    if email_date > filter_to:
                        continue
            
            # Calculate relevance score (1 - distance for cosine)
            distance = search_results["distances"][i] if search_results["distances"] else 0
            relevance_score = 1 - distance
            
        
        return results
    
    def hybrid_search(self, request: SemanticSearchRequest) -> List[SearchResult]:
        """
        Perform hybrid search combining BM25 and semantic search.
        
        Args:
            request: Search request with query and filters
            
        Returns:
            List of search results with combined scores
        """
        # Get more results than requested to account for filtering
        n_results = request.limit * 3
        
        # 1. Get BM25 results
        bm25_results = bm25_search.search(request.query, n_results=n_results)
        bm25_scores = {email_id: score for email_id, score in bm25_results}
        
        # Normalize BM25 scores to 0-1 range
        if bm25_scores:
            max_bm25 = max(bm25_scores.values())
            if max_bm25 > 0:
                bm25_scores = {k: v / max_bm25 for k, v in bm25_scores.items()}
        
        # 2. Get semantic search results
        query_embedding = embedding_processor.encode(request.query)
        
        where_filter = None
        if request.filters:
            where_filter = self._build_chroma_filter(request.filters)
        
        search_results = vector_store.search(
            query_embedding=query_embedding,
            n_results=n_results,
            where=where_filter
        )
        
        # Build semantic scores (1 - distance for cosine similarity)
        semantic_scores = {}
        for i, email_id in enumerate(search_results["ids"]):
            distance = search_results["distances"][i] if search_results["distances"] else 0
            semantic_scores[email_id] = 1 - distance
        
        # 3. Combine scores
        all_email_ids = set(bm25_scores.keys()) | set(semantic_scores.keys())
        combined_scores = {}
        
        for email_id in all_email_ids:
            bm25_score = bm25_scores.get(email_id, 0)
            semantic_score = semantic_scores.get(email_id, 0)
            
            # Weighted combination
            combined_score = (
                settings.bm25_weight * bm25_score +
                settings.semantic_weight * semantic_score
            )
            combined_scores[email_id] = combined_score
        
        # Sort by combined score
        sorted_email_ids = sorted(
            combined_scores.keys(),
            key=lambda x: combined_scores[x],
            reverse=True
        )
        
        # 4. Build results
        results = []
        for email_id in sorted_email_ids:
            email = self.db.query(Email).filter(Email.id == email_id).first()
            if not email:
                continue
            
            # Apply date filters
            if request.filters:
                if request.filters.date_from and email.date:
                    email_date = email.date.replace(tzinfo=None) if email.date.tzinfo else email.date
                    filter_from = request.filters.date_from.replace(tzinfo=None) if request.filters.date_from.tzinfo else request.filters.date_from
                    if email_date < filter_from:
                        continue
                if request.filters.date_to and email.date:
                    email_date = email.date.replace(tzinfo=None) if email.date.tzinfo else email.date
                    filter_to = request.filters.date_to.replace(tzinfo=None) if request.filters.date_to.tzinfo else request.filters.date_to
                    if filter_to.hour == 0 and filter_to.minute == 0 and filter_to.second == 0:
                        filter_to = filter_to + timedelta(days=1) - timedelta(seconds=1)
                    if email_date > filter_to:
                        continue
            
            # Get snippet
            snippet = self._get_snippet(email.body, request.query) if email.body else None
            
            # Get matched entities
            matched_entities = [e.text for e in email.entities[:5]]
            
            results.append(SearchResult(
                email_id=email.id,
                subject=email.subject,
                sender=email.sender,
                date=email.date,
                relevance_score=round(combined_scores[email_id], 4),
                snippet=snippet,
                matched_entities=matched_entities
            ))
            
            if len(results) >= request.limit:
                break
        
        return results
    
    def find_similar(self, request: SimilarEmailRequest) -> List[SearchResult]:
            matched_entities = [e.text for e in email.entities[:5]]
            
            results.append(SearchResult(
                email_id=email.id,
                subject=email.subject,
                sender=email.sender,
                date=email.date,
                relevance_score=round(relevance_score, 4),
                snippet=snippet,
                matched_entities=matched_entities
            ))
            
            if len(results) >= request.limit:
                break
        
        return results
    
    def find_similar(self, request: SimilarEmailRequest) -> List[SearchResult]:
        """
        Find emails similar to a given email.
        
        Args:
            request: Request with source email ID
            
        Returns:
            List of similar emails
        """
        similar = vector_store.find_similar(
            id=request.email_id,
            n_results=request.limit
        )
        
        results = []
        for item in similar:
            email = self.db.query(Email).filter(Email.id == item["id"]).first()
            if not email:
                continue
            
            results.append(SearchResult(
                email_id=email.id,
                subject=email.subject,
                sender=email.sender,
                date=email.date,
                relevance_score=round(item["score"], 4) if item["score"] else 0,
                snippet=email.body[:200] if email.body else None,
                matched_entities=[]
            ))
        
        return results
    
    def keyword_search(
        self,
        request: KeywordSearchRequest
    ) -> tuple[List[SearchResult], int]:
        """
        Perform keyword search on emails.
        
        Args:
            request: Search request
            
        Returns:
            Tuple of (results, total count)
        """
        query = self.db.query(Email)
        
        # Search in subject and body
        search_term = f"%{request.query}%"
        query = query.filter(
            or_(
                Email.subject.ilike(search_term),
                Email.body.ilike(search_term)
            )
        )
        
        # Apply filters
        if request.filters:
            if request.filters.date_from:
                query = query.filter(Email.date >= request.filters.date_from)
            if request.filters.date_to:
                query = query.filter(Email.date <= request.filters.date_to)
            if request.filters.sender:
                query = query.filter(Email.sender.ilike(f"%{request.filters.sender}%"))
        
        # Get total count
        total = query.count()
        
        # Apply pagination
        offset = (request.page - 1) * request.limit
        emails = query.order_by(Email.date.desc()).offset(offset).limit(request.limit).all()
        
        results = []
        for email in emails:
            snippet = self._get_snippet(email.body, request.query) if email.body else None
            
            results.append(SearchResult(
                email_id=email.id,
                subject=email.subject,
                sender=email.sender,
                date=email.date,
                relevance_score=1.0,  # Keyword match
                snippet=snippet,
                matched_entities=[]
            ))
        
        return results, total
    
    def _build_chroma_filter(self, filters: SearchFilters) -> Optional[Dict[str, Any]]:
        """Build ChromaDB metadata filter."""
        conditions = []
        
        if filters.sender:
            conditions.append({"sender": {"$eq": filters.sender}})
        
        if not conditions:
            return None
        
        if len(conditions) == 1:
            return conditions[0]
        
        return {"$and": conditions}
    
    def _get_snippet(self, text: str, query: str, max_length: int = 200) -> str:
        """Extract a relevant snippet from text."""
        if not text:
            return ""
        
        # Find query in text
        query_lower = query.lower()
        text_lower = text.lower()
        
        pos = text_lower.find(query_lower)
        if pos == -1:
            # Query not found, return beginning
            return text[:max_length] + "..." if len(text) > max_length else text
        
        # Extract snippet around the match
        start = max(0, pos - max_length // 2)
        end = min(len(text), pos + len(query) + max_length // 2)
        
        snippet = text[start:end]
        
        # Add ellipsis if needed
        if start > 0:
            snippet = "..." + snippet
        if end < len(text):
            snippet = snippet + "..."
        
        return snippet

